<!DOCTYPE html>

<html lang="en" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>cpt &#8212; funcsim 0.1.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=5ecbeea2" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css?v=12dfc556" />
    <script src="../_static/documentation_options.js?v=01f34227"></script>
    <script src="../_static/doctools.js?v=9a2dae69"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for cpt</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;calculate cumulative prospect theory expected value and certainty equiv&quot;&quot;&quot;</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">math</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">itertools</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">collections</span><span class="w"> </span><span class="kn">import</span> <span class="n">namedtuple</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">Iterable</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">scipy</span>


<span class="k">class</span><span class="w"> </span><span class="nc">InferenceError</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Error indicating that solving for the certainty equivalent failed.&quot;&quot;&quot;</span>


<div class="viewcode-block" id="utilPower">
<a class="viewcode-back" href="../api_reference.html#funcsim.utilPower">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">utilPower</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
              <span class="n">alpha</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.88</span><span class="p">,</span>
              <span class="n">beta</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.88</span><span class="p">,</span>
              <span class="n">lamb</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">2.25</span><span class="p">,</span>
              <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the power utility for gains and losses with loss aversion.</span>

<span class="sd">    This function implements the power utility function used in cumulative</span>
<span class="sd">    prospect theory in Tversky and Kahneman (1992), with separate risk aversion</span>
<span class="sd">    parameters for gains and losses, and a loss aversion parameter.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : float</span>
<span class="sd">        The outcome value.</span>
<span class="sd">    alpha : float, optional</span>
<span class="sd">        Risk aversion parameter for gains (default is 0.88).</span>
<span class="sd">        Must be in [0.0, 1.0].</span>
<span class="sd">    beta : float, optional</span>
<span class="sd">        Risk aversion parameter for losses (default is 0.88).</span>
<span class="sd">        Must be in [0.0, 1.0].</span>
<span class="sd">    lamb : float, optional</span>
<span class="sd">        Loss aversion parameter (default is 2.25).</span>
<span class="sd">        Must be &gt;= 1.0.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    float</span>
<span class="sd">        The utility value for the given outcome.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    For x &gt;= 0, utility is x**alpha (or log(x) if alpha == 0).</span>
<span class="sd">    For x &lt; 0, utility is -lamb * (-x)**beta (or -lamb * log(-x) if beta == 0).</span>
<span class="sd">    Default parameter values are from Tversky and Kahneman (1992).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="nb">float</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;alpha must be a float between 0.0 and 1.0&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">alpha</span> <span class="o">&lt;</span> <span class="mf">0.0</span> <span class="ow">or</span> <span class="n">alpha</span> <span class="o">&gt;</span> <span class="mf">1.0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;alpha must be between 0.0 and 1.0&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">beta</span><span class="p">,</span> <span class="nb">float</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;beta must be a float between 0.0 and 1.0&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">beta</span> <span class="o">&lt;</span> <span class="mf">0.0</span> <span class="ow">or</span> <span class="n">beta</span> <span class="o">&gt;</span> <span class="mf">1.0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;beta must be between 0.0 and 1.0&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lamb</span><span class="p">,</span> <span class="nb">float</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;lamb must be a float &gt;= 1.0&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">lamb</span> <span class="o">&lt;</span> <span class="mf">1.0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;lamb must be greater or equal to 1.0&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">x</span> <span class="o">&gt;=</span> <span class="mf">0.0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">if</span> <span class="n">alpha</span> <span class="o">==</span> <span class="mf">0.0</span> <span class="k">else</span> <span class="n">x</span><span class="o">**</span><span class="n">alpha</span>
    <span class="k">return</span> <span class="o">-</span><span class="n">lamb</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="o">-</span><span class="n">x</span><span class="p">)</span> <span class="k">if</span> <span class="n">beta</span> <span class="o">==</span> <span class="mf">0.0</span> <span class="k">else</span> <span class="o">-</span><span class="n">lamb</span> <span class="o">*</span> <span class="p">(</span><span class="o">-</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="n">beta</span></div>



<div class="viewcode-block" id="utilNormLog">
<a class="viewcode-back" href="../api_reference.html#funcsim.utilNormLog">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">utilNormLog</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
                <span class="n">gamma</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.223</span><span class="p">,</span>
                <span class="n">delta</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.000</span><span class="p">,</span>
                <span class="n">lamb</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">2.25</span><span class="p">,</span>
                <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute normalized logarithmic utility from Rachlin (1992) for gains and</span>
<span class="sd">    losses with loss aversion.</span>

<span class="sd">    This function implements the normalized log utility used in cumulative</span>
<span class="sd">    prospect theory, with separate curvature parameters for gains and losses,</span>
<span class="sd">    and a loss aversion parameter.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : float</span>
<span class="sd">        The outcome value.</span>
<span class="sd">    gamma : float, optional</span>
<span class="sd">        Curvature parameter for gains (default is 1.223).</span>
<span class="sd">    delta : float, optional</span>
<span class="sd">        Curvature parameter for losses (default is 0.0).</span>
<span class="sd">    lamb : float, optional</span>
<span class="sd">        Loss aversion parameter (default is 2.25).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    float</span>
<span class="sd">        The utility value for the given outcome.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    For x &gt;= 0, utility is x if gamma == 0, else log(1 + gamma * x) / gamma.</span>
<span class="sd">    For x &lt; 0, utility is lamb * x if delta == 0, else</span>
<span class="sd">    -lamb * log(1 - delta * x) / delta.</span>
<span class="sd">    Default parameter values are from Bouchoiuicha &amp; Vieider (2017) and</span>
<span class="sd">    Tversky and Kahneman (1992).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">x</span> <span class="o">&gt;=</span> <span class="mf">0.0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">x</span> <span class="k">if</span> <span class="n">gamma</span> <span class="o">==</span> <span class="mf">0.0</span> <span class="k">else</span> <span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="n">gamma</span> <span class="o">*</span> <span class="n">x</span><span class="p">)</span> <span class="o">/</span> <span class="n">gamma</span>
    <span class="k">return</span> <span class="n">lamb</span> <span class="o">*</span> <span class="n">x</span> <span class="k">if</span> <span class="n">delta</span> <span class="o">==</span> <span class="mf">0.0</span> <span class="k">else</span> \
        <span class="o">-</span><span class="n">lamb</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">delta</span> <span class="o">*</span> <span class="n">x</span><span class="p">)</span> <span class="o">/</span> <span class="n">delta</span></div>



<div class="viewcode-block" id="weightTK">
<a class="viewcode-back" href="../api_reference.html#funcsim.weightTK">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">weightTK</span><span class="p">(</span><span class="n">p</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
             <span class="n">gamma</span><span class="p">:</span> <span class="nb">float</span>
             <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the Tversky and Kahneman (1992) probability weighting function.</span>

<span class="sd">    This function applies the probability distortion function used in</span>
<span class="sd">    cumulative prospect theory, as proposed by Tversky and Kahneman (1992).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    p : float</span>
<span class="sd">        Probability value in the range [0.0, 1.0].</span>
<span class="sd">    gamma : float</span>
<span class="sd">        Distortion parameter, must be between 0.28 and 1.0.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    float</span>
<span class="sd">        The weighted (distorted) probability.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError</span>
<span class="sd">        If p is not in [0.0, 1.0] or gamma is not in [0.28, 1.0].</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    For gamma &lt; 1, small probabilities are overweighted and large</span>
<span class="sd">    probabilities are underweighted.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">p</span> <span class="o">&lt;</span> <span class="mf">0.0</span> <span class="ow">or</span> <span class="n">p</span> <span class="o">&gt;</span> <span class="mf">1.0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;probabilities must be within [0.0, 1.0]&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">gamma</span> <span class="o">&lt;</span> <span class="mf">0.28</span> <span class="ow">or</span> <span class="n">gamma</span> <span class="o">&gt;</span> <span class="mf">1.0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;gamma must be between 0.28 and 1&#39;</span><span class="p">)</span>

    <span class="n">num</span> <span class="o">=</span> <span class="n">p</span> <span class="o">**</span> <span class="n">gamma</span>
    <span class="n">denom</span> <span class="o">=</span> <span class="p">(</span><span class="n">p</span> <span class="o">**</span> <span class="n">gamma</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">p</span><span class="p">)</span> <span class="o">**</span> <span class="n">gamma</span><span class="p">)</span> <span class="o">**</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">gamma</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">num</span> <span class="o">/</span> <span class="n">denom</span></div>



<div class="viewcode-block" id="weightPrelec1">
<a class="viewcode-back" href="../api_reference.html#funcsim.weightPrelec1">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">weightPrelec1</span><span class="p">(</span><span class="n">p</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
                  <span class="n">gamma</span><span class="p">:</span> <span class="nb">float</span>
                  <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the Prelec (1998) one-parameter probability weighting function.</span>

<span class="sd">    This function applies the one-parameter Prelec probability distortion</span>
<span class="sd">    function, commonly used in cumulative prospect theory, to a probability</span>
<span class="sd">    value.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    p : float</span>
<span class="sd">        Probability value in the range [0.0, 1.0].</span>
<span class="sd">    gamma : float</span>
<span class="sd">        Distortion parameter. Typical values are in (0, 1].</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    float</span>
<span class="sd">        The weighted (distorted) probability.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError</span>
<span class="sd">        If p is not in [0.0, 1.0].</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    For gamma &lt; 1, small probabilities are overweighted and large</span>
<span class="sd">    probabilities are underweighted.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">p</span> <span class="o">&lt;</span> <span class="mf">0.0</span> <span class="ow">or</span> <span class="n">p</span> <span class="o">&gt;</span> <span class="mf">1.0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;probabilities must be within [0.0, 1.0]&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">p</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">:</span>
        <span class="k">return</span> <span class="mf">0.0</span>
    <span class="n">inner</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.0</span> <span class="o">*</span> <span class="p">(</span><span class="o">-</span><span class="mf">1.0</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">p</span><span class="p">))</span> <span class="o">**</span> <span class="n">gamma</span>
    <span class="k">return</span> <span class="n">math</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">inner</span><span class="p">)</span></div>



<div class="viewcode-block" id="weightPrelec2">
<a class="viewcode-back" href="../api_reference.html#funcsim.weightPrelec2">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">weightPrelec2</span><span class="p">(</span><span class="n">p</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
                  <span class="n">alpha</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
                  <span class="n">beta</span><span class="p">:</span> <span class="nb">float</span>
                  <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the Prelec (1998) two-parameter probability weighting function.</span>

<span class="sd">    This function applies the two-parameter Prelec probability distortion</span>
<span class="sd">    function, commonly used in cumulative prospect theory, to a probability</span>
<span class="sd">    value.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    p : float</span>
<span class="sd">        Probability value in the range [0.0, 1.0].</span>
<span class="sd">    alpha : float</span>
<span class="sd">        Slope or sensitivity parameter. Typical values are in (0, 1].</span>
<span class="sd">    beta : float</span>
<span class="sd">        Elevation parameter. Typical values are positive.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    float</span>
<span class="sd">        The weighted (distorted) probability.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError</span>
<span class="sd">        If p is not in [0.0, 1.0].</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    For alpha &lt; 1, small probabilities are overweighted and large</span>
<span class="sd">    probabilities are underweighted.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">p</span> <span class="o">&lt;</span> <span class="mf">0.0</span> <span class="ow">or</span> <span class="n">p</span> <span class="o">&gt;</span> <span class="mf">1.0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;probabilities must be within [0.0, 1.0]&#39;</span><span class="p">)</span>

    <span class="k">return</span> <span class="mf">0.0</span> <span class="k">if</span> <span class="n">p</span> <span class="o">==</span> <span class="mf">0.0</span> <span class="k">else</span> <span class="n">math</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">beta</span> <span class="o">*</span> <span class="p">(</span><span class="o">-</span><span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">p</span><span class="p">))</span><span class="o">**</span><span class="n">alpha</span><span class="p">)</span></div>



<span class="k">class</span><span class="w"> </span><span class="nc">_accDict</span><span class="p">:</span>
    <span class="c1"># accumulator dictionary</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_d</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;add a value to dict if the key is not already present&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_d</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_d</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_d</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">+=</span> <span class="n">val</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">final</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;return the dictionary&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_d</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_makeDistinct</span><span class="p">(</span><span class="n">outcomes</span><span class="p">,</span> <span class="n">probs</span><span class="p">):</span>
    <span class="c1"># given an iterable of possibly non-unique outcomes and an iterable of</span>
    <span class="c1"># their corresponding probabilities, return a list of *distinct* outcomes</span>
    <span class="c1"># and a list of their corresponding *total* probabilities</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">outcomes</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">probs</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">outcomes</span><span class="p">))</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">outcomes</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">outcomes</span><span class="p">,</span> <span class="n">probs</span><span class="p">)</span>

    <span class="c1"># warning: mutating d</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">_accDict</span><span class="p">()</span>
    <span class="n">_</span> <span class="o">=</span> <span class="p">[</span><span class="n">d</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">outcomes</span><span class="p">,</span> <span class="n">probs</span><span class="p">)]</span>
    <span class="n">final</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">final</span>

    <span class="c1"># return lists, being sure to preserve correspondence</span>
    <span class="n">keys</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">final</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">keys</span><span class="p">,</span> <span class="p">[</span><span class="n">final</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">])</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_validate_psum</span><span class="p">(</span><span class="n">psum</span><span class="p">):</span>
    <span class="c1"># due to numerical imprecision, we may occasional get a cumulative</span>
    <span class="c1"># probability that is 1.00000000007 or something.  Filter these out</span>
    <span class="c1"># so they do not cause trouble in the probability weighting functions</span>
    <span class="k">return</span> <span class="p">[</span><span class="nb">min</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">psum</span><span class="p">]</span>


<span class="c1"># container for results</span>
<span class="n">CptResult</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s2">&quot;CptResult&quot;</span><span class="p">,</span> <span class="s2">&quot;ExpectedValue CertaintyEquiv&quot;</span><span class="p">)</span>


<div class="viewcode-block" id="cpt">
<a class="viewcode-back" href="../api_reference.html#funcsim.cpt">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">cpt</span><span class="p">(</span><span class="n">utilFunc</span><span class="p">:</span> <span class="n">Callable</span><span class="p">,</span>
        <span class="n">weightFuncGains</span><span class="p">:</span> <span class="n">Callable</span><span class="p">,</span>
        <span class="n">weightFuncLosses</span><span class="p">:</span> <span class="n">Callable</span><span class="p">,</span>
        <span class="n">outcomes</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
        <span class="n">refOutcome</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">probabilities</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Iterable</span><span class="p">[</span><span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">precision</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span>
        <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">CptResult</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute cumulative prospect theory (CPT) value and certainty equivalent.</span>

<span class="sd">    This function calculates the CPT expected value and certainty equivalent</span>
<span class="sd">    for a set of outcomes, using user-supplied utility and probability</span>
<span class="sd">    weighting functions. It supports arbitrary outcome distributions and</span>
<span class="sd">    reference points.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    utilFunc : Callable</span>
<span class="sd">        Utility function taking a single outcome as input.  See ``utilPower``</span>
<span class="sd">        and ``utilNormLog``.</span>
<span class="sd">    weightFuncGains : Callable</span>
<span class="sd">        Probability weighting function for gains.  See ``weightTK``,</span>
<span class="sd">        ``weightPrelec1``, and ``weightPrelec2``.</span>
<span class="sd">    weightFuncLosses : Callable</span>
<span class="sd">        Probability weighting function for losses.</span>
<span class="sd">    outcomes : Iterable</span>
<span class="sd">        Sequence of possible stochastic outcomes.</span>
<span class="sd">    refOutcome : float</span>
<span class="sd">        Reference point for gains and losses.</span>
<span class="sd">    probabilities : float or Iterable, optional</span>
<span class="sd">        Probabilities for each outcome. If None, outcomes are assumed</span>
<span class="sd">        equally likely.</span>
<span class="sd">    precision : float, optional</span>
<span class="sd">        Precision for numerically finding the certainty equivalent.</span>
<span class="sd">        Default is 1.0, which is suitable for outcomes with magnitudes up to</span>
<span class="sd">        perhaps 100,000.  For outcomes with smaller maximum magnitudes, smaller</span>
<span class="sd">        values for precision should probably be used.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    CptResult</span>
<span class="sd">        Named tuple with fields:</span>
<span class="sd">        - ExpectedValue : float</span>
<span class="sd">        - CertaintyEquiv : float</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError</span>
<span class="sd">        If probabilities are negative or do not sum to 1.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The function supports both unique and repeated outcomes. Probabilities</span>
<span class="sd">    are assumed equal for all outcomes if the user does not provide</span>
<span class="sd">    probabilities. Certainty equivalent is found by</span>
<span class="sd">    solving utilFunc(C.E. - refOutcome) = CPT value.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">probabilities</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">min</span><span class="p">(</span><span class="n">probabilities</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">0.0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;probabilities must be non-negative&#39;</span><span class="p">)</span>

    <span class="c1"># assume all outcomes are equally likely if no probabilities were passed</span>
    <span class="n">outcomesList</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">outcomes</span><span class="p">)</span>  <span class="c1"># in case a generator was passed</span>
    <span class="n">probs_orig</span> <span class="o">=</span> <span class="n">probabilities</span> <span class="k">if</span> <span class="n">probabilities</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> \
        <span class="k">else</span> <span class="nb">len</span><span class="p">(</span><span class="n">outcomesList</span><span class="p">)</span> <span class="o">*</span> <span class="p">[</span><span class="mf">1.0</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">outcomesList</span><span class="p">))]</span>

    <span class="c1"># be sure that outcomes are distinct/unique</span>
    <span class="p">(</span><span class="n">out_distinct</span><span class="p">,</span> <span class="n">probs_tot</span><span class="p">)</span> <span class="o">=</span> <span class="n">_makeDistinct</span><span class="p">(</span><span class="n">outcomesList</span><span class="p">,</span> <span class="n">probs_orig</span><span class="p">)</span>

    <span class="c1"># apply reference point if it is not zero</span>
    <span class="n">out</span> <span class="o">=</span> <span class="p">[</span><span class="n">o</span> <span class="o">-</span> <span class="n">refOutcome</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">out_distinct</span><span class="p">]</span>

    <span class="c1"># pair conditioned outcomes and their probabilities, sort by outcome value</span>
    <span class="n">pairs</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">probs_tot</span><span class="p">))</span>

    <span class="c1"># main calcs</span>
    <span class="n">pos_pairs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">p</span><span class="p">:</span> <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">pairs</span><span class="p">))))</span>
    <span class="n">neg_pairs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">p</span><span class="p">:</span> <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">pairs</span><span class="p">))</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">pairsToVf</span><span class="p">(</span><span class="n">pares</span><span class="p">,</span> <span class="n">wfunc</span><span class="p">):</span>
        <span class="n">psum_prelim</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">accumulate</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">pares</span><span class="p">))</span>
        <span class="n">psum</span> <span class="o">=</span> <span class="n">_validate_psum</span><span class="p">(</span><span class="n">psum_prelim</span><span class="p">)</span>
        <span class="n">psum_lag</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">]</span> <span class="o">+</span> <span class="n">psum</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">((</span><span class="n">wfunc</span><span class="p">(</span><span class="n">psum</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">-</span> <span class="n">wfunc</span><span class="p">(</span><span class="n">psum_lag</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
                   <span class="o">*</span> <span class="n">utilFunc</span><span class="p">(</span><span class="n">pares</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">psum</span><span class="p">)))</span>

    <span class="n">Vfpos</span> <span class="o">=</span> <span class="n">pairsToVf</span><span class="p">(</span><span class="n">pos_pairs</span><span class="p">,</span> <span class="n">weightFuncGains</span><span class="p">)</span>
    <span class="n">Vfneg</span> <span class="o">=</span> <span class="n">pairsToVf</span><span class="p">(</span><span class="n">neg_pairs</span><span class="p">,</span> <span class="n">weightFuncLosses</span><span class="p">)</span>
    <span class="n">cptEval</span> <span class="o">=</span> <span class="n">Vfpos</span> <span class="o">+</span> <span class="n">Vfneg</span>

    <span class="c1"># calculate certainty equiv: find ce such that</span>
    <span class="c1"># utilFunc(ce - refOutcome) = cptEval</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">trySolve</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">x1</span><span class="p">):</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">obj</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">utilFunc</span><span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">refOutcome</span><span class="p">)</span> <span class="o">-</span> <span class="n">cptEval</span>

        <span class="k">return</span> <span class="n">scipy</span><span class="o">.</span><span class="n">optimize</span><span class="o">.</span><span class="n">root_scalar</span><span class="p">(</span><span class="n">f</span><span class="o">=</span><span class="n">obj</span><span class="p">,</span>
                                          <span class="n">x0</span><span class="o">=</span><span class="n">x0</span><span class="p">,</span>
                                          <span class="n">x1</span><span class="o">=</span><span class="n">x1</span><span class="p">,</span>
                                          <span class="n">maxiter</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span>
                                          <span class="n">rtol</span><span class="o">=</span><span class="n">precision</span><span class="p">)</span>

    <span class="c1"># using ugly mutation to try to find certainty equivalent using</span>
    <span class="c1"># different sets of starting points</span>
    <span class="n">decrement</span> <span class="o">=</span> <span class="mf">0.05</span> <span class="o">*</span> <span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">outcomesList</span><span class="p">)</span> <span class="o">-</span> <span class="nb">min</span><span class="p">(</span><span class="n">outcomesList</span><span class="p">))</span>
    <span class="n">xtop</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">outcomesList</span><span class="p">)</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">trySolve</span><span class="p">(</span><span class="n">x0</span><span class="o">=</span><span class="nb">min</span><span class="p">(</span><span class="n">outcomesList</span><span class="p">),</span> <span class="n">x1</span><span class="o">=</span><span class="n">xtop</span><span class="p">)</span>
    <span class="k">while</span> <span class="n">result</span><span class="o">.</span><span class="n">converged</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
        <span class="n">xtop</span> <span class="o">=</span> <span class="n">xtop</span> <span class="o">-</span> <span class="n">decrement</span>
        <span class="k">if</span> <span class="n">xtop</span> <span class="o">&lt;=</span> <span class="nb">min</span><span class="p">(</span><span class="n">outcomesList</span><span class="p">):</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="sa">f</span><span class="s2">&quot;could not find certainty equivalent&quot;</span>
                   <span class="sa">f</span><span class="s2">&quot; min(outcome)=</span><span class="si">{</span><span class="nb">min</span><span class="p">(</span><span class="n">outcomesList</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
                   <span class="sa">f</span><span class="s2">&quot; max(outcome)=</span><span class="si">{</span><span class="nb">max</span><span class="p">(</span><span class="n">outcomesList</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
                   <span class="sa">f</span><span class="s2">&quot; obj@minOutcome=&quot;</span>
                   <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">utilFunc</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">outcomesList</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">refOutcome</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">cptEval</span><span class="si">}</span><span class="s2">&quot;</span>
                   <span class="sa">f</span><span class="s2">&quot; obj@maxOutcome=&quot;</span>
                   <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">utilFunc</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">outcomesList</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">refOutcome</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">cptEval</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">raise</span> <span class="n">InferenceError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">trySolve</span><span class="p">(</span><span class="n">x0</span><span class="o">=</span><span class="nb">min</span><span class="p">(</span><span class="n">outcomesList</span><span class="p">),</span> <span class="n">x1</span><span class="o">=</span><span class="n">xtop</span><span class="p">)</span>

    <span class="c1"># return if we found the certainty equivalent</span>
    <span class="n">certEquiv</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">root</span>
    <span class="k">return</span> <span class="n">CptResult</span><span class="p">(</span><span class="n">ExpectedValue</span><span class="o">=</span><span class="n">cptEval</span><span class="p">,</span> <span class="n">CertaintyEquiv</span><span class="o">=</span><span class="n">certEquiv</span><span class="p">)</span></div>



<div class="viewcode-block" id="cptBV">
<a class="viewcode-back" href="../api_reference.html#funcsim.cptBV">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">cptBV</span><span class="p">(</span><span class="n">outcomes</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">,</span>
          <span class="n">refOutcome</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
          <span class="n">probabilities</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Iterable</span><span class="p">[</span><span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span>
          <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">CptResult</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute cumulative prospect theory value and certainty equivalent using</span>
<span class="sd">    Bouchoiuicha &amp; Vieider (2017) recommended functional forms and parameters.</span>

<span class="sd">    This function calculates the cumulative prospect theory (CPT) expected value</span>
<span class="sd">    and certainty equivalent for a set of outcomes, using preset utility and</span>
<span class="sd">    probability weighting functions and parameters from Bouchoiuicha &amp; Vieider</span>
<span class="sd">    (2017).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    outcomes : Iterable</span>
<span class="sd">        Sequence of possible stochastic outcomes.</span>
<span class="sd">    refOutcome : float</span>
<span class="sd">        Reference point for gains and losses.</span>
<span class="sd">    probabilities : float or Iterable, optional</span>
<span class="sd">        Probabilities for each outcome. If None, outcomes are assumed equally</span>
<span class="sd">        likely.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    CptResult</span>
<span class="sd">        Named tuple with fields:</span>
<span class="sd">        - ExpectedValue : float            </span>
<span class="sd">        - CertaintyEquiv : float</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Uses utilNormLog for utility, weightPrelec2 for gains and losses, and</span>
<span class="sd">    parameter values recommended by Bouchoiuicha &amp; Vieider (2017).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">cpt</span><span class="p">(</span><span class="n">utilFunc</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">utilNormLog</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">gamma</span><span class="o">=</span><span class="mf">1.223</span><span class="p">,</span> <span class="n">delta</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span>
                                              <span class="n">lamb</span><span class="o">=</span><span class="mf">2.25</span><span class="p">),</span>
               <span class="n">weightFuncGains</span><span class="o">=</span><span class="k">lambda</span> <span class="n">p</span><span class="p">:</span> <span class="n">weightPrelec2</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.53</span><span class="p">,</span>
                                                       <span class="n">beta</span><span class="o">=</span><span class="mf">0.969</span><span class="p">),</span>
               <span class="n">weightFuncLosses</span><span class="o">=</span><span class="k">lambda</span> <span class="n">p</span><span class="p">:</span> <span class="n">weightPrelec2</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.623</span><span class="p">,</span>
                                                        <span class="n">beta</span><span class="o">=</span><span class="mf">0.953</span><span class="p">),</span>
               <span class="n">outcomes</span><span class="o">=</span><span class="n">outcomes</span><span class="p">,</span>
               <span class="n">refOutcome</span><span class="o">=</span><span class="n">refOutcome</span><span class="p">,</span>
               <span class="n">probabilities</span><span class="o">=</span><span class="n">probabilities</span><span class="p">)</span></div>

</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">funcsim</a></h1>








<h3>Navigation</h3>
<p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../overview.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../api_reference.html">API Reference</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
  <li><a href="index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &#169;2017-2025, Henry Bryant.
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 7.4.7</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 0.7.16</a>
      
    </div>

    

    
  </body>
</html>